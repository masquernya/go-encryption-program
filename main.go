package main

import (
	"encoding/base64"
	"fmt"
	"github.com/masquernya/go-encryption-program/encryption"
	"github.com/masquernya/go-encryption-program/ferret"
	"github.com/masquernya/go-encryption-program/humanize"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
	"unicode/utf8"
)

var commands = map[string]struct {
	Arguments   []string
	Description string
}{
	"help": {
		Arguments:   []string{},
		Description: "print this help message",
	},
	"encrypt-file": {
		Arguments:   []string{"<publickey>", "<filepath>"},
		Description: "encrypt file with public key, saving to <filepath>.enc",
	},
	"decrypt-file": {
		Arguments:   []string{"<filepath>"},
		Description: "decrypt file, saving to <filepath>.dec. private key is read from the PRIVATE_KEY environmental variable.",
	},
	"genkey": {
		Arguments:   []string{},
		Description: "generate public and private key, then print it to the terminal.",
	},
	"genkeyword": {
		Arguments:   []string{"<mode>", "<case sensitive>", "<word>"},
		Description: "generate public and private key with <word>, then print it to the terminal. <case sensitive> is true or false. <mode> is prefix or any",
	},
	"decrypt-nacl": {
		Arguments:   []string{"<message>"},
		Description: "decrypt anonymous nacl box message (Base64 encoded) and print it to the terminal. private key is read from the PRIVATE_KEY environmental variable.",
	},
	"encrypt-nacl": {
		Arguments:   []string{"<publickey>", "<message>"},
		Description: "encrypt message with public key and print it to the terminal (Base64 encoded)",
	},
	"humanize-key": {
		Arguments:   []string{"<publickey>"},
		Description: "convert a base64 encoded public key to a string of words",
	},
	"dehumanize-key": {
		Arguments:   []string{"<key>"},
		Description: "convert a string of words generated by humanize-key to a base64 encoded public key",
	},
}

func printHelp() {
	fmt.Println("OwO1 Encryption Standard. Essentially NaCL box with chunk support.")
	fmt.Println("Commands:")
	for cmd, data := range commands {
		fmt.Print("\n")
		fmt.Println("" + cmd + " " + strings.Join(data.Arguments, " "))
		fmt.Println("    " + data.Description)
	}
	os.Exit(0)
}

func main() {
	if len(os.Args) < 2 || os.Args[1] == "help" {
		printHelp()
	}

	if os.Args[1] == "genkey" {
		publicKey, privateKey, err := encryption.GenerateKeys()
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		fmt.Println("Public Key (Base64):")
		fmt.Println(base64.StdEncoding.EncodeToString(publicKey))
		fmt.Println("Private Key (Base64):")
		fmt.Println(base64.StdEncoding.EncodeToString(privateKey))
		os.Exit(0)
	} else if os.Args[1] == "genkeyword" {
		if len(os.Args) < 5 {
			printHelp()
		}
		mode := os.Args[2]
		caseSensitive, err := strconv.ParseBool(os.Args[3])
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		prefix := os.Args[4]
		if !caseSensitive {
			prefix = strings.ToLower(prefix)
		}
		ch := make(chan [][]byte)
		//var attempts int64 = 0
		//var attemptsMux sync.Mutex
		start := time.Now()
		threadCount := runtime.NumCPU()
		for i := 0; i < threadCount; i++ {
			go (func() {
				var myPublicKey []byte
				var myPrivateKey []byte
				var err error
				for {
					myPublicKey, myPrivateKey, err = encryption.GenerateKeys()
					if err != nil {
						fmt.Println(err)
						os.Exit(1)
					}

					if mode == "prefix" {
						kb64 := base64.StdEncoding.EncodeToString(myPublicKey[0:len(prefix)])
						if !caseSensitive {
							kb64 = strings.ToLower(kb64)
						}

						if strings.HasPrefix(kb64, prefix) {
							fmt.Println("took", time.Since(start))
							s := strings.Repeat("^", len(prefix))
							ch <- [][]byte{myPublicKey, myPrivateKey, []byte(s)}
						}
					} else if mode == "suffix" {
						kb64 := base64.StdEncoding.EncodeToString(myPublicKey)
						if !caseSensitive {
							kb64 = strings.ToLower(kb64)
						}

						for strings.HasSuffix(kb64, "=") {
							kb64 = kb64[:len(kb64)-1]
						}
						if strings.HasSuffix(kb64, prefix) {
							fmt.Println("took", time.Since(start))
							s := strings.Repeat(" ", len(kb64)-len(prefix))
							s += strings.Repeat("^", len(prefix))
							ch <- [][]byte{myPublicKey, myPrivateKey, []byte(s)}
						}
					} else if mode == "any" {
						kb64 := base64.StdEncoding.EncodeToString(myPublicKey)
						if !caseSensitive {
							kb64 = strings.ToLower(kb64)
						}
						pos := strings.Index(kb64, prefix)
						if pos != -1 {
							strLocation := strings.Repeat(" ", pos)
							strLocation += strings.Repeat("^", utf8.RuneCountInString(prefix))
							fmt.Println("took", time.Since(start))
							ch <- [][]byte{myPublicKey, myPrivateKey, []byte(strLocation)}
							break
						}
					} else {
						panic("invalid mode")
					}
				}
			})()
		}
		keys := <-ch
		fmt.Println("Public Key (Base64):")
		fmt.Println(base64.StdEncoding.EncodeToString(keys[0]))
		fmt.Println(string(keys[2]))
		fmt.Println("Private Key (Base64):")
		fmt.Println(base64.StdEncoding.EncodeToString(keys[1]))
		os.Exit(0)
	} else if os.Args[1] == "encrypt-file" {
		if len(os.Args) < 4 {
			printHelp()
		}
		publicKey, err := base64.StdEncoding.DecodeString(os.Args[2])
		if err != nil {
			panic(err)
		}
		inFilePath := os.Args[3]
		outFilePath := inFilePath + ".enc"
		err = ferret.EncryptFile(inFilePath, outFilePath, publicKey)
		if err != nil {
			panic(err)
		}
		fmt.Println("File encrypted and saved to " + outFilePath)
	} else if os.Args[1] == "decrypt-file" {
		if len(os.Args) < 3 {
			printHelp()
		}
		privateKeyStr, privateKeyExists := os.LookupEnv("PRIVATE_KEY")
		if !privateKeyExists {
			fmt.Println("Environment variable PRIVATE_KEY not found")
			os.Exit(1)
		}
		privateKey, err := base64.StdEncoding.DecodeString(privateKeyStr)
		if err != nil {
			panic(err)
		}

		inFilePath := os.Args[2]
		outFilePath := inFilePath + ".dec"

		err = ferret.DecryptFile(inFilePath, outFilePath, privateKey)
		if err != nil {
			panic(err)
		}
		fmt.Println("File decrypted and saved to " + outFilePath)
	} else if os.Args[1] == "encrypt-nacl" {
		if len(os.Args) < 3 {
			printHelp()
		}
		publicKey, err := base64.StdEncoding.DecodeString(os.Args[2])
		if err != nil {
			panic(err)
		}
		message := os.Args[3]

		encrypted, err := encryption.PublicKeyEncrypt(publicKey, []byte(message))
		if err != nil {
			panic(err)
		}
		fmt.Println("Encrypted message (Base64):")
		fmt.Println(base64.StdEncoding.EncodeToString(encrypted))

	} else if os.Args[1] == "decrypt-nacl" {
		if len(os.Args) < 3 {
			printHelp()
		}
		privateKeyStr, privateKeyExists := os.LookupEnv("PRIVATE_KEY")
		if !privateKeyExists {
			fmt.Println("Environment variable PRIVATE_KEY not found")
			os.Exit(1)
		}
		privateKey, err := base64.StdEncoding.DecodeString(privateKeyStr)
		if err != nil {
			panic(err)
		}

		message, err := base64.StdEncoding.DecodeString(os.Args[2])
		if err != nil {
			panic(err)
		}

		decrypted, err := encryption.PublicKeyDecrypt(privateKey, message)
		if err != nil {
			panic(err)
		}

		ok := utf8.Valid(decrypted)
		if !ok {
			fmt.Println("Message (Base64):")
			fmt.Println(base64.StdEncoding.EncodeToString(decrypted))
			os.Exit(0)
		}
		fmt.Println(string(decrypted))
	} else if os.Args[1] == "humanize-key" {
		if len(os.Args) < 3 {
			printHelp()
		}
		key, err := base64.StdEncoding.DecodeString(os.Args[2])
		if err != nil {
			panic(err)
		}
		fmt.Println("Humanized key:")
		fmt.Println(humanize.GetString(key))
	} else if os.Args[1] == "dehumanize-key" {
		if len(os.Args) < 3 {
			printHelp()
		}
		key := os.Args[2]
		fmt.Println("Dehumanized key (Base64):")
		fmt.Println(base64.StdEncoding.EncodeToString(humanize.GetBytes(key)))
	} else {
		printHelp()
	}
}
